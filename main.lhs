%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0


%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
\documentclass[sigplan,screen,review,anonymous]{acmart}

\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}

\newcommenter{\plr}{magenta}{PLR}

%%%% lhs2Tex (*.lhs) document
\let\Bbbk\undefined
%include polycode.fmt
\long\def\ignore#1{}

%%%% %% Rights management information.  This information is sent to you
%%%% %% when you complete the rights form.  These commands have SAMPLE
%%%% %% values in them; it is your responsibility as an author to replace
%%%% %% the commands and values with those provided to you when you
%%%% %% complete the rights form.
%%%% \setcopyright{acmcopyright}
%%%% \copyrightyear{2018}
%%%% \acmYear{2018}
%%%% \acmDOI{XXXXXXX.XXXXXXX}

%%%% %% Submission ID.
%%%% %% Use this when submitting an article to a sponsored event. You'll
%%%% %% receive a unique submission ID from the organizers
%%%% %% of the event, and this ID should be used as the parameter to this command.
%%%% \acmSubmissionID{123-A56-BU3}

%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting the next command will enable that style.
\citestyle{acmauthoryear}

%% end of the preamble, start of the body of the document source.
\begin{document}


%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{An Exceptional Actor System (Functional Pearl)}

%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Patrick Redmond}
\orcid{0000-0001-5702-0860}
\author{Lindsey Kuper}
\affiliation{
  \institution{University of California, Santa Cruz}
  \country{USA}
}

%%%% %% By default, the full list of authors will be used in the page
%%%% %% headers. Often, this list is too long, and will overlap
%%%% %% other information printed in the page headers. This command allows
%%%% %% the author to define a more concise list
%%%% %% of authors' names for this purpose.
%%%% \renewcommand{\shortauthors}{Trovato et al.}

%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
    The Glasgow Haskell Compiler is well known for its fully featured runtime
    system (RTS) which includes green threads, asynchronous exceptions, and
    recently delimited continuations.
    %
    The interactions between these features and the forthcoming effect
    handling system may be nontrivial.

    We present a user accessible actor framework hidden in plain sight within
    the RTS and demonstrate it on a classic example.
    %
    We then extend both the framework and example to the realm of dynamic
    types.
    %
    Finally we raise questions about the expressiveness and subsumption of
    programming language features.
\end{abstract}

%%%% %%
%%%% %% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%%%% %% Please copy and paste the code instead of the example below.
%%%% %%
%%%% \begin{CCSXML}
%%%% <ccs2012>
%%%%  <concept>
%%%%   <concept_id>10010520.10010553.10010562</concept_id>
%%%%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%%%%   <concept_significance>500</concept_significance>
%%%%  </concept>
%%%%  <concept>
%%%%   <concept_id>10010520.10010575.10010755</concept_id>
%%%%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%%%%   <concept_significance>300</concept_significance>
%%%%  </concept>
%%%%  <concept>
%%%%   <concept_id>10010520.10010553.10010554</concept_id>
%%%%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%%%%   <concept_significance>100</concept_significance>
%%%%  </concept>
%%%%  <concept>
%%%%   <concept_id>10003033.10003083.10003095</concept_id>
%%%%   <concept_desc>Networks~Network reliability</concept_desc>
%%%%   <concept_significance>100</concept_significance>
%%%%  </concept>
%%%% </ccs2012>
%%%% \end{CCSXML}
%%%% 
%%%% \ccsdesc[500]{Computer systems organization~Embedded systems}
%%%% \ccsdesc[300]{Computer systems organization~Redundancy}
%%%% \ccsdesc{Computer systems organization~Robotics}
%%%% \ccsdesc[100]{Networks~Network reliability}

%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{
    actor framework,
    asynchronous exceptions,
    runtime system,
    programming languages
}

%%%% \received{20 February 2007}
%%%% \received[revised]{12 March 2009}
%%%% \received[accepted]{5 June 2009}

%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle



\section{TODO: Introduction}

\plr{TODO}

\subsection{Exceptions in GHC}

The Glasgow Haskell Compiler (GHC) supports three varieties of exceptions, all
of which may be caught in the IO monad and otherwise cause the program to
terminate.
%
\emph{Imprecise exceptions} arise in pure code from expressions such as
\verb|(div 1 0)| which cannot be reduced further.
%
\emph{Synchronous exceptions} are thrown when side effects in the IO monad
cannot proceed such as \verb|(readFile "\0")|.
%
\emph{Asynchronous exceptions} are thrown by threads distinct from the current
one, or the RTS itself, to communicate conditions requiring the thread to
terminate: thread cancellation, user interrupts, or memory limits.
%
We focus on asynchronous exceptions.

Asynchronous exceptions uniquely allow syntactically-distant parts of a program
to interact.
%
A thread needs only the \verb|ThreadId| of another
to throw a \verb|ThreadKilled| exception to it.
The standard library function \verb|killThread|
is even implemented as \verb|(\x -> throwTo x ThreadKilled)|.\footnote{
    These identifiers are variously defined in \texttt{Control.Concurrent} and
    \texttt{Control.Exception} in \texttt{base-4.15.1.0}.
}
%
There is no permission or capability required to access this powerful feature.

Asynchronous exceptions are peculiar because they aren't constrained to their
stated purpose of ``signaling (or killing) one
thread by another'' \cite{marlow2001async}.
%
A thread may throw any exception to any thread for any reason.
%
Standard exceptions may be reused to extend greetings as in,
\verb|(\x -> throwTo x $ AssertionFailed "hello")|.
%
User defined datatypes may even be thrown as asynchronous exceptions by
declaring an instance of \verb|Exception| \cite{marlow2006extensible}.
%
Given the two lines of declarations below it is possible to greet in
vernacular, \verb|(\x -> throwTo x Hi)|.
%
\begin{spec}
data Greet = Hi | Hello deriving Show
instance Exception Greet
\end{spec}

Asynchronous exceptions may be caught by the receiving thread for
either cleanup or surprisingly, recovery.
%
An example of recovery includes ``inform[ing] the program when memory is
running out [so] it can take remedial action'' \cite{marlow2001async}.
%
The ability to recover from a termination signal seems innocuous, but combined
with the rest, asynchronous exceptions facilitate ``spooky action at a
distance'' in ways one might want to constrain in a functional programming
language.

\subsection{The actor model}

The actor model is a computational paradigm characterized by message passing.
%
\citet{hewitt1973actors} says, ``an actor can be thought of as a kind of
virtual processor that is never "busy" [in the sense that it cannot be sent a
message].''
%
In modern terms, we might say an actor is a green-thread with some state and an
inbox.
%
Upon receipt of a message to its inbox, an actor may perform some actions: send
a message, update state, create a new actor, destroy an actor, or terminate
itself.
%
Having completed that, the actor waits to process the next message in its
inbox.
%
We will approximate this model with Haskell's asynchronous exceptions as the
primary metaphor for message passing.

\citet{armstrong2003} provides additional definition for actors in their list of characteristics of a concurrency oriented programming language (COPL).
%
Every COPL
(1) has processes,
(2) which are strongly isolated,
(3) with a unique hidden identifier,
(4) without shared state,
(5) that communicate via unreliable message passing,
and
(6) can detect when another process halts.
%
Additionally
(5a) message passing is asynchronous so that no stuck recipient may cause a sender to become stuck,
(5b) receiving a response is the only way to know that a prior message was delivered,
and
(5c) messages between two processes obey FIFO ordering.
%
While an actor system within an instance of the RTS cannot satisfy all of these
requirements (e.g. termination of the main thread is not strongly isolated from
the child threads), we will show that ours satisfies many requirements of being COPL with relatively little effort.





\section{Implementation}

We define that an actor is a Haskell thread.
%
An actor thread runs a library-provided main-loop function which mediates
message receipt and calls to a user-defined handler function.
%
Here we describe the minimal abstractions around such threads which realize the
actor model.

From this point forward, all code listings are part of a literate Haskell
file.\footnote{
We use \verb|GHC 9.0.2| and \verb|base-4.15.1.0| and the following imports:
%
\begin{code}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE DuplicateRecordFields #-} -- Section 3.2
{-# LANGUAGE ViewPatterns #-} -- Section 3.3
-- Section 2.1, 2.2
import Control.Exception (Exception(..), throwTo, catch, mask_)
import Control.Concurrent (ThreadId, myThreadId, threadDelay)
-- Section 2.3
import Control.Exception (TypeError(..))
-- Section 3.2
import Control.Concurrent (forkIO)
import System.Random (RandomGen, randomR, getStdRandom)
-- Section 3.3
import Control.Exception (SomeException)
\end{code}
\ignore{
\begin{code}
import Control.Concurrent (killThread)
import System.IO (hSetBuffering, stdout, BufferMode(..))
\end{code}
}
}
%
Our implementation requires a few definitions from Haskell's \verb|base|
package.
%
We simplify our presentation with an extension to enable construction and
pattern-matches using binders named the same as fields,
and
an extension allowing two records to share the same field name.
\plr{Mention viewpatterns}


\subsection{Sending (throwing) messages}

To send a message we will throw an exception to the recipient thread's
identifier.
%
So that the recipient may respond, we define a self-addressed envelope data
type.
%
This envelope and the message content must both be instances of
\verb|Exception| and \verb|Show|.
%
\begin{code}
data Envelope a = Envelope { sender :: ThreadId, message :: a }
    deriving Show

instance Exception a => Exception (Envelope a)
\end{code}
%
With the envelope defined, our send function reads the current thread
identifier, constructs a self-addressed envelope, and throws it to the
specified recipient, in Figure \ref{fig:send-static}.
%
For the purpose of explication in this paper, it also prints a trace.
%
\begin{figure}[h]
\begin{code}
sendStatic :: Exception a => ThreadId -> a -> IO ()
sendStatic recipient message = do
    sender <- myThreadId
    putStrLn (show sender ++ " send " ++ show message
                          ++ " to " ++ show recipient)
    throwTo recipient Envelope{sender, message}
\end{code}
\caption{Send a message in a self-addressed envelope.}
\label{fig:send-static}
\end{figure}


\subsection{Receiving (catching) messages}

Every actor thread runs a library-provided main-loop function to manage message
receipt and processing.
%
The main-loop installs an exception handler to accumulate messages in an inbox
and calls a user-defined handler on each.
%
The user-defined handler encodes actor intentions (or behavior) as a
state-transition that takes a self-addressed envelope as its second argument.
%
\begin{code}
type Handler st msg = st -> Envelope msg -> IO st
\end{code}

Figure \ref{fig:runStatic} defines \verb|runStatic| which takes a \verb|Handler|
and its initial state and does not return.
%
Then \verb|runStatic| masks asynchronous exceptions so they will only be raised
at well-defined points and runs its loop under that mask.

\begin{figure}[h]
\begin{code}
runStatic :: Exception a => Handler s a -> s -> IO ()
runStatic handler initialState = mask_ $ loop (initialState, [])
  where
    loop (state, inbox) =
        catch
            (case inbox of
                [] -> threadDelay 60000000 >> return (state, inbox)
                x:xs -> (,) <$> handler state x <*> return xs)
            (\e@Envelope{} -> return (state, inbox ++ [e]))
        >>= loop
\end{code}
\caption{Actor-thread message-receipt main-loop.}
\label{fig:runStatic}
\end{figure}

The loop has two pieces of state: that of \verb|Handler| and an inbox of
messages to be processed.
%
The loop body is divided roughly into three cases by an exception
handler and a case-split on the inbox list.
%
(1) If the inbox is empty, sleep for 60 seconds and then recurse on the
unchanged  and empty inbox.
%
(2) If the inbox has a message, call the handler and recurse on the
updated handler-state and remainder of the inbox.
%
(3) If during cases (1) or (2) an \verb|Envelope| exception is received,
recurse on unchanged handler-state and an inbox with the new envelope appended
to the end.

In the normal course of things, an actor will start with an empty inbox and go
to sleep.
%
If a message is received during sleep, the actor will wake (because
\verb|threadDelay| is defined to be \emph{interruptible}) and add the message
to its inbox.
%
On the next loop iteration the actor will process that message and once again
have an empty inbox.
%
Exceptions are masked outside of interruptible actions so that the bookkeeping
of recursing with updated state through the loop is not disrupted.

\paragraph{Unsafety}

Before moving forward, let us acknowledge that this is \emph{not safe}.
%
An exception may arrive while executing the handler.
%
Despite the exception mask which we have intentionally left in place, if the
handler executes an interruptible action then it will be preempted.
%
In this case the handler's work will be unfinished.
%
Without removing the message currently being processed, the loop
will continue on an inbox extended with the new message.
%
The next iteration will begin by processing the same message that the preempted
iteration was, effecting a double-send.

To avoid the possibility of a double-send, a careful implementor of a
\verb|Handler| might follow the documented recommendations (use software
transactional memory (STM), or avoid interruptible actions, or apply
\verb|uninterruptibleMask|), but recall that message sending is implemented
with \verb|throwTo| which is ``\emph{always} interruptible, even if does not
actually block'' \cite{controlDotException}.
%
Here be dragons.

\paragraph{Aspects of a COPL}

Which requirements to be a COPL does this system display?
%
RTS threads behave as independent processes, and although not strongly
isolated and able to share state, they have a unique hidden \verb|ThreadId|.

The implementation as shown encourages communication via \emph{reliable
synchronous message passing with FIFO order}.
%
We call it synchronous because ``\verb|throwTo| does not return until the
exception is received by the target thread''
\cite{controlDotException}.\footnote{
	``Synchronous for me, but not for thee'' might be the most correct
	characterization. Senders may experience GHC's asynchronous exceptions as
	synchronous, but recipients will always perceive them as asynchronous.
}
%
This means that a sender may block if the recipient never reaches an
interruptible point (e.g. its handler function enters an infinite loop in pure
computation).
%
Assuming handler functions terminate, instead the framework will tend to
exhibit the behavior of \emph{reliable asynchronous message passing with FIFO
order} and occasional double-sends.
%
By wrapping calls to \verb|sendStatic| with \verb|forkIO|
\cite{marlow2001async}, we obtain \emph{reliable asynchronous message passing
without FIFO order} even in the presence of non-terminating handler
functions.\footnote{
    If thread $T_1$ forks thread $T_2$ to send message $M_2$, and then $T_1$
    forks thread $T_3$ to send message $M_3$, the RTS scheduler may first run
    $T_3$ resulting in $M_3$ reaching the recipient before $M_2$, violating
    FIFO.
}
%
FIFO can be recovered by message sequence numbers or (albeit, jumping the
shark) use of an outbox-thread per actor.
%
An actor can reliably inform others of its termination with use of
\verb|forkFinally|.\footnote{
	\verb|forkIO| and \verb|forkFinally| are defined in
	\texttt{Control.Concurrent} in \texttt{base-4.15.1.0}.
}

\plr{Digresses slightly from COPL, but still relevant to armstrong.}
Our choice to wrap a user-defined message type in a known envelope type has the
benefit of allowing the actor main-loop to distinguish between messages and
exceptions, allowing the latter to terminate the thread as intended.
%
At the same time this choice runs afoul of the \emph{name distribution problem}
\cite{armstrong2003} by indiscriminately informing all recipients of the sender
process identifier.

\paragraph{Perspective}
We have in only a few lines of code discovered an actor framework within the
RTS which makes no explicit use of channels, references, or locks and imports
just a few names from the default modules.
%
The likelihood of double sends might temper enthusiasm for this discovery, but
despite minor brokenness it is notable that this is possible.




\subsection{Dynamic types}
\label{sec:dynamic-types}

The actor main-loop in Figure \ref{fig:runStatic} constrains an actor thread
to handle messages of a single type.
%
An envelope containing the wrong message type will not be caught by the
exception handler, causing the receiving actor to crash.
%
In this section we correct this issue by extending the framework to support
actors that may receive messages of different types.
%
We hesitate to identify it as a dynamically-typed actor framework.

Instead of sending an \verb|Envelope| of some application-specific message
type, we convert messages to the ``any type'' in Haskell's the exception
hierarchy, \verb|SomeException|.
%
Therefore all inflight messages will be \verb|Envelope| of
\verb|SomeException|.
%
\begin{code}
send :: Exception a => ThreadId -> a -> IO ()
send recipient = sendStatic recipient . toException
\end{code}
\plr{Is the eta-reduction in this definition confusing?}

On the receiving side, messages must now be downcast to the \verb|Handler|
message type.
%
This is an opportunity to treat messages of the wrong type specially.
%
We define a \verb|run| function which lifts any \verb|Handler| to one that can
receive envelopes containing \verb|SomeException|.
%
If the message downcast fails, instead of the recipient crashing, it performs a
``return to sender.''
%
Specifically, it throws an exception (not an envelope) with a run-time type
error.\footnote{
    The extensions \texttt{ScopedTypeVariables}, \texttt{TypeApplications}, and
    the function \texttt{Data.Typeable.typeOf} can be used to construct a very
    helpful type-error message for debugging actor programs.
}
%
\begin{code}
run :: Exception a => Handler s a -> s -> IO ()
run handlerStatic = runStatic handler
  where
    handler state e@Envelope{sender, message} =
        case fromException message of
            Just m -> handlerStatic state e{message=m}
            Nothing
                -> throwTo sender (TypeError "...")
                >> return state
\end{code}
\plr{Is the eta-reduction in this definition confusing?}

A close reader will note that these changes haven't directly empowered actor
handler-functions to deal with messages of different types, only lifted our
infrastructure to remove the type parameter from envelopes.
%
In fact, actors that wish to receive messages of different types will do so by
performing the downcast from \verb|SomeException| themselves.
%
Section \ref{sec:dyn-ring} will show an example of an actor which receives
messages of different types, by extending an actor that doesn't.






\section{Case study: Ring leader-election}
\label{sec:case-study}

\subsection{Problem and solution sketch}
\label{sec:ring-impl}

The problem of \emph{ring leader-election} is to designate one node among a
network of nodes that communicate with a ring topology
\cite{lelann1977distributed}.
%
The nodes do not know the number or identities of the other nodes except for
their immediate successor ``next'' node.
%
A satisfying solution will result in one node being designated the winner.
%
Though this is a classic problem in distributed systems literature, it might
not be practical to apply to threads in a process.
%
It is nonetheless interesting and we use it for demonstration.

\citet{chang1979decentralextrema} describe a solution in which every node
simultaneously nominates itself to its successor.
%
Upon receiving a nomination, a node forwards it if the nominee is greater than
itself and ignores it otherwise.
%
We implement and extend that solution below.

\subsection{Implementing elections}

\subsubsection{State and messages}

Each node begins uninitialized, and is later made a member of the ring
when it learns the identity of its successor.
%
Therefore our node state type will have two constructors.
%
\begin{code}
type Id = ThreadId
data Node = Uninitialized | Member {next::Id}
\end{code}
%
The main thread will create multiple node actors and then initialize the ring by
informing each node of its successor.
%
Next the main thread will instruct one node actor to start the algorithm.
%
Finally, the nodes will complete the algorithm by sending nominations.
%
Accordingly our message type has three constructors.
\begin{code}
data Msg = Init{next::Id} | Start | Nominate{nominee::Id}
    deriving Show
instance Exception Msg
\end{code}

\subsubsection{Actor behavior}

The \verb|Handler| for a node actor will have state of type \verb|Node| and
pass messages of type \verb|Msg|. We describe each case separately.
%
\begin{code}
node :: Handler Node Msg
\end{code}
%
When an uninitialized node receives an \verb|Init| message, it becomes a member
of the ring and remembers its successor.
%
\begin{code}
node Uninitialized
  Envelope{message=Init{next}} = do
    return Member{next}
\end{code}
%
When a member of the ring receives a \verb|Start| message, it nominates itself
to its successor in the ring.
%
\begin{code}
node state@Member{next}
  Envelope{message=Start} = do
    self <- myThreadId
    send next $ Nominate self
    return state
\end{code}
%
Figure \ref{fig:ring-nominate} shows the case which characterizes
this algorithm.
%
When a member of the ring receives a \verb|Nominate| message, it nominates
the greater of itself and the received nominee to its successor in the ring.
%
If the nominee is the current node, it wins and the algorithm stops.
%
\begin{figure}[h]
\begin{code}
node state@Member{next}
  Envelope{message=Nominate{nominee}} = do
    self <- myThreadId
    case () of
     _  |  self == nominee -> putStrLn (show self ++ ": I win")
        |  self <  nominee -> send next (Nominate nominee)
        |  otherwise       -> putStrLn "Ignored nominee"
    return state
\end{code}
\caption{Node behavior upon receiving a nomination.}
\label{fig:ring-nominate}
\end{figure}

\subsubsection{Initialization}
\label{sec:ring-init}

The main thread performs several steps to initialize the algorithm:
(1) Create some number of actor threads.
(2) Randomize the order of the \verb|ThreadId|s in a list.
(3) Inform each thread of the \verb|ThreadId| that follows it in the random
order (its successor).
(4) Tell one thread to start the algorithm.
%
These tasks are implemented in \verb|ringElection|.\footnote{
    The implementation shown doesn't handle degenerate rings of size 0 or 1,
    but we consider that out of scope of the demonstration.
}
%
\begin{samepage}
\begin{code}
ringElection :: Int -> IO () -> IO [ThreadId]
ringElection n actor = do
    nodes <- sequence . replicate n $ forkIO actor {-"\quad\quad\hfill (1)"-}
    ring <- getStdRandom $ permute nodes {-"\hfill (2)"-}
    mapM_
        (\(self, next) -> send self Init{next}) {-"\hfill (3)"-}
        (zip ring $ tail ring ++ [head ring])
    mapM_ (\tid -> send tid Start) ring {-"\hfill (4)"-}
    return ring
\end{code}
\end{samepage}
%
Finally, the election algorithm is initiated in \verb|main1| by passing the
node handler and the uninitialized state to \verb|run|.
%
This results in an \verb|IO ()| value representing the behavior of a node
actor, which we pass to \verb|ringElection| to be run on several threads.
%
We include a trace of \verb|main1| in Appendix \ref{sec:main1-trace}.
%
\begin{samepage}
\begin{code}
main1 :: Int -> IO ()
main1 count = do
    ring <- ringElection count $ run node Uninitialized
    return ()
\end{code}
\ignore{
\begin{code}
    threadDelay 1000000
    mapM_ killThread ring
\end{code}
}
\end{samepage}

\subsection{Adding a victory round}
\label{sec:dyn-ring}

The solution we have shown solves the ring leader-election problem
insofar as a single node concludes that it has won.
%
However, it is also desirable for the other nodes to learn the outcome of the
election.
%
To that end we will extend the existing solution using the dynamic types
support from Section \ref{sec:dynamic-types} to add an additional message type
and behaviors.

The additions are:
%
(1) Each node will keep track of the greatest nominee it has seen.
%
(2) When the winner self-identifies, they will start an extra round
declaring themselves winner.
%
(3) Upon receiving a winner declaration, nodes will compare their greatest
nominee seen with the winner declaration; if agreeable, then they forward the
declaration, otherwise they ignore it.

When a node receives a declaration of the winner that they agree with, they
have ``learned'' that node is indeed the winner.
%
When the winner receives their own declaration, everyone has learned they are
the winner.

\subsubsection{State and messages}

Each node now has a \verb|Node| paired with a \verb|ThreadId| that
represents the greatest nominee it has seen.
%
\begin{code}
type Node' = (Node, ThreadId)
\end{code}
%
The new message type has only one constructor to declare the winner.
%
\begin{code}
data Winner = Winner ThreadId
    deriving Show
instance Exception Winner
\end{code}

\subsubsection{Actor behavior}

The handler function for the new actor will use \verb|Node'| as described, but we
declare its message type to be \verb|SomeException|.
%
\begin{code}
node' :: Handler Node' SomeException
\end{code}
%
Recall the implementation of \verb|run| from Section \ref{sec:dynamic-types}.
%
That function calls \verb|fromException| which here is inferred to return
\verb|Maybe SomeException| and succeeds unconditionally.
%
The actor handler function must now deal with this, and so we enable
\verb|ViewPatterns| to perform downcasts in pattern matches.

There are two main cases, corresponding to the two message types the actor will
handle.
%
The first case applies when a node downcasts the envelope contents to
\verb|Msg|.
%
It tracks the last-seen nominee and triggers the winner round.
%
There are several steps:
%
(1) Delegate to the held node by putting the revealed \verb|Msg| back into the
envelope and passing it through the \verb|node| handler function from Section
\ref{sec:ring-impl}.
%
Return that resulting node state in all of the cases below.
%
(2) If the message is a nomination of the current node, start the winner round
because the election is over.
%
(3) Otherwise the election is ongoing so keep track of the greatest nominee
seen.
%
(4) For any other \verb|Msg| constructors, only return the updated state.
%
\begin{samepage}
\begin{code}
node' (n, great)
  e@Envelope{message=fromException -> Just m} = do
    self <- myThreadId
    n'@Member{next} <- node n e{message=m} {-"\quad\quad\hfill (1)"-}
    case m of
        Nominate{nominee} ->
            if self == nominee
            then send next (Winner self) {-"\quad\quad\hfill (2)"-}
                >> return (n', great)
            else return (n', max nominee great) {-"\quad\quad\hfill (3)"-}
        _ -> return (n', great) {-"\quad\quad\hfill (4)"-}
\end{code}
\end{samepage}
%
The second case applies when a node downcasts the envelope contents to a winner
declaration.
%
State is unchanged in all three cases:
%
If the current node is declared winner, the algorithm stops.
%
If the greatest nominee the current node has seen is declared winner, forward
the declaration.
%
If some unknown node is declared winner, complain and ignore the message.
%
\begin{code}
node' state@(Member{next}, great)
  Envelope{message=fromException -> Just m} = do
    self <- myThreadId
    case m of
        Winner w
            | w == self -> putStrLn (show self ++ ": Confirmed")
            | w == great -> send next (Winner w)
            | otherwise -> putStrLn "Unexpected winner"
    return state
\end{code}

\subsubsection{Initialization}
\label{sec:ring2-init}

The extended ring leader-election can reuse the same scaffolding as before; we
only define a \verb|main2| function.
%
As part of the \verb|IO ()| action passed to \verb|ringElection|, each thread
initializes its greatest nominee seen to itself.
%
A trace of \verb|main2| is in Appendix \ref{sec:main2-trace}.
%
\begin{samepage}
\begin{code}
main2 :: Int -> IO ()
main2 count = do
    ring <- ringElection count $ do
        great <- myThreadId
        run node' (Uninitialized, great)
    return ()
\end{code}
\ignore{
\begin{code}
    threadDelay 1000000
    mapM_ killThread ring
\end{code}
}
\end{samepage}





\subsection{TODO: Performance evaluation}

\plr{TODO}




\section{Feature subsumption}

Can you implement an actor framework with Haskell's threads and asynchronous
exceptions?
%
This is the question that lead us to writing this paper.
%
Figure \ref{fig:runStatic} shows that you very nearly can, and this fact hints
that perhaps asynchronous exceptions are more general than actors.

When we discussed this research at an informal gathering, a participant asked
whether algebraic effects could be used to implement asynchronous exceptions.
%
This lead us to a lively discussion:
%
Can you implement them in terms of delimited continuations?
%
What does this mean for the design of exception systems? 
%
What is the relationship to coroutines?
%
\plr{
Are Haskell's asynchronous exceptions truly asynchronous, given that a sender
could block?
}

\citet[p.~40]{sussman1975interpreter} say, ``we discovered that the "actors"
and the lambda expressions were identical in implementation.






\section{TODO: Conclusion}

\plr{TODO}











%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
To you, for reading this.
Ack the PLV people
\end{acks}

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{main.bib}











%% If your work has an appendix, this is the place to put it.
\appendix

\section{Appendix}

% It's necessary to have a main function, but I'm excluding it from appearing
% in the document.
\ignore{
\begin{code}
main :: IO ()
main = do
    putStrLn "Enter count:"
    count <- fmap read getLine
    beginVerb
    main1 count
    putStrLn ""
    main2 count
    endVerb
\end{code}
}

\subsection{Permute}

In Section \ref{sec:ring-impl} we provided the implementation of a ring
leader-election in our actor framework.
%
The implementation used \verb|permute| to randomize the list of
\verb|ThreadId|.
%
Its implementation is as follows:
%
Repeatedly pop a random element from the input and add it to the output.
%
\begin{samepage}
\begin{code}
permute :: RandomGen g => [a] -> g -> ([a], g)
permute pool0 gen0
    = snd
    . foldr pick (pool0, ([], gen0))
    $ replicate (length pool0) ()
  where
    pick () (pool, (output, g)) =
        let (index, g') = randomR (0, length pool - 1) g
            (x, pool') = pop pool index
        in (pool', (x:output, g'))
    pop (x:xs) 0 = (x, xs)
    pop (x:xs) n = (x:) <$> pop xs (n - 1)
    pop [] _ = error "pop empty list"
\end{code}
\end{samepage}






\ignore{
\begin{code}
beginVerb :: IO ()
beginVerb = do
    hSetBuffering stdout LineBuffering
    putStrLn "\\begin{verbatim}"

endVerb :: IO ()
endVerb = putStrLn "\\end{verbatim}"
\end{code}
}

%options ghci -threaded -rtsopts -with-rtsopts=-N

\subsection{Election trace}
\label{sec:main1-trace}

In Section \ref{sec:ring-init} we defined \verb|main1| to run a ring
leader-election.
%
Here's an example trace.

\footnotesize
\perform{beginVerb >> putStrLn "> main1 8" >> main1 8 >> endVerb }
\normalsize

\subsection{Dynamic types trace}
\label{sec:main2-trace}

In Section \ref{sec:ring2-init} we defined \verb|main2| to run a ring
leader-election with a winner declaration round.
%
Here's an example trace.

\footnotesize
\perform{beginVerb >> putStrLn "> main2 8" >> main2 8 >> endVerb }
\normalsize














\end{document}
\endinput
